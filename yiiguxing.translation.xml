<application>
  <component name="AppStorage">
    <histories>
      <item value="&lt;p&gt;For example, consider a task consisting of the activities: A, B, C, D. If D calls startActivity() with an Intent that resolves to the component of activity B, then C and D will be finished and B receive the given Intent, resulting in the stack now being: A, B." />
      <item value="If set, and the activity being launched is already running in the current task, then instead of launching a new instance of that activity, all of the other activities on top of it will be closed and this Intent will be delivered to the (now on top) old activity as a new Intent." />
      <item value="Returns the value mapped by {@code name} if it exists, coercing it if necessary, or {@code fallback} if no such mapping exists." />
      <item value="反思" />
      <item value="未定义定义的引用" />
      <item value="恢复" />
      <item value="valerie" />
      <item value="incident" />
      <item value="firmware" />
      <item value="All we will be going through all the retail product milestones, please take a look at the below – we will be scrubbing / triaging bugs and feature starting tomorrow.  Leads, please come in and prepare to talk about the bugs / features assigned to you or your team members.   " />
      <item value="spec" />
      <item value="draft" />
      <item value="shadow" />
      <item value="shadowsocks" />
      <item value="by default" />
      <item value="estimate" />
      <item value="定时模式" />
      <item value="定时控制模式" />
      <item value="定时" />
      <item value="gateway" />
      <item value="gate Way" />
      <item value="Expected" />
      <item value="return true if a tethered device is found, false if not found" />
      <item value="Checks where tethering is on. This is determined by the getTetheredIfaces() method, that will return an empty array if not devices are tethered" />
      <item value="tethered" />
      <item value="Tether" />
      <item value="is Tether Active" />
      <item value="estimating" />
      <item value="brightness" />
      <item value="height" />
      <item value="width" />
      <item value="register BroadcastReceiver to monitor USB events" />
      <item value="called after device opend" />
      <item value="called when device attached" />
      <item value="difficult" />
      <item value="Reflect" />
      <item value="Reflection" />
      <item value="gnss" />
      <item value="bandwidth" />
      <item value="验证" />
      <item value="摄像头存在打开失败" />
      <item value="有摄像头打开失败" />
      <item value="Registers to receive notifications about changes in the system default network. The callbacks will continue to be called until either the application exits or {@link #unregisterNetworkCallback(NetworkCallback)} is called." />
      <item value="Called when the network the framework connected to for this request changes capabilities but still satisfies the stated need." />
      <item value="Called if no network is found in the timeout time specified in {@link #requestNetwork(NetworkRequest, NetworkCallback, int)} call. This callback is not called for the version of {@link #requestNetwork(NetworkRequest, NetworkCallback)} without timeout. When this callback is invoked the associated {@link NetworkRequest} will have already been removed and released, as if {@link #unregisterNetworkCallback(NetworkCallback)} had been called." />
      <item value="Called when the framework has a hard loss of the network or when the graceful failure ends." />
      <item value="Called when the network is about to be disconnected. Often paired with an {@link NetworkCallback#onAvailable} call with the new replacement network for graceful handover. This may not be called if we have a hard loss (loss without warning). This may be followed by either a {@link NetworkCallback#onLost} call or a {@link NetworkCallback#onAvailable} call for this network depending on whether we lose or regain it." />
      <item value="Called when the framework connects and has declared a new network ready for use. This callback may be called more than once if the {@link Network} that is satisfying the request changes. This will always immediately be followed by a call to {@link #onCapabilitiesChanged(Network, NetworkCapabilities)} then by a call to {@link #onLinkPropertiesChanged(Network, LinkProperties)}." />
      <item value="Called when the framework connects and has declared a new network ready for use. This callback may be called more than once if the {@link Network} that is satisfying the request changes." />
      <item value="Called when the framework connects to a new network to evaluate whether it satisfies this request. If evaluation succeeds, this callback may be followed by an {@link #onAvailable} callback. There is no guarantee that this new network will satisfy any requests, or that the network will stay connected for longer than the time necessary to evaluate it." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="98" />
        <entry key="ENGLISH" value="99" />
        <entry key="ROMANIAN" value="1" />
        <entry key="PORTUGUESE" value="2" />
        <entry key="JAPANESE" value="4" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="googleTranslateSettings">
      <google-translate>
        <option name="primaryLanguage" value="CHINESE" />
      </google-translate>
    </option>
    <option name="ignoreRegExp" value="" />
  </component>
</application>